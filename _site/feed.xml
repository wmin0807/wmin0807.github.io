<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title></title>
		<description>Stylish Jekyll Theme</description>
		<link>/</link>
		<atom:link href="/" rel="self" type="application/rss+xml" />
		
			<item>
				<title>spring对JMS整合的简单介绍</title>
				<description>&lt;p&gt;JMS是Java Message Service 的简写，也就是Java消息服务。它是面向异步消息而制定的标准API，一种异步通信的机制，当异步发送消息的时候，客户端不需要等待服务器处理消息，甚至不需要等待消息被投递，就可以继续执行的程序。异步消息是一个应用程序向另一个应用程序间接发送消息的一种方式，这种方式无需等待对方的响应。&lt;/p&gt;

&lt;p&gt;首先需要了解JMS中存在两个主要概念：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;消息代理(message broker)，当客户端发送异步消息就必然会有一个消息服务器（broker）来帮助它完成消息的转发，而这个服务器就是消息服务器。&lt;/li&gt;
  &lt;li&gt;目的地(destination)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;JMS中目的地有两种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;队列，队列也称为点对点模型&lt;/li&gt;
  &lt;li&gt;主题，主题也称为发布/订阅模型&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;点对点的消息模型：&lt;/p&gt;

&lt;p&gt;每条消息都有一个发送者和一个接收者。当消息代理得到消息时，它将消息放入一个队列中，接收者从这个队列接受消息，接受后该条消息从队列中删除，这样就可以保证消息只能投递给一个接收者。&lt;/p&gt;

&lt;p&gt;发布-订阅消息模型：&lt;/p&gt;

&lt;p&gt;消息会发送给一个主题，多个接收者都可以订阅这个主题，但是消息发送者并不知道。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;下面是一个基于ActiveMQ的消息服务器，同时使用Spring对JMS的整合来发送和接受消息。&lt;/p&gt;

&lt;p&gt;首先使用Maven建立工程，pom需要引入以下几个依赖：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;4.1.3.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;org.apache.activemq&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;activemq-core&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;5.7.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;spring-jms&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;4.1.4.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后需要在Spring的配置文件中创建activemq的链接工厂，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;bean id=&quot;connectionFactory&quot; 
	&quot;class=&quot;org.apache.activemq.spring.ActiveMQConnectionFactory&quot;&amp;gt;
	&amp;lt;property name=&quot;brokerURL&quot; value=&quot;tcp://localhost:61616&quot; /&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的brokerURL值就是代理服务器（activemq）的地址，由于在本地启动所以设置成localhost,61616为默认的占用端口。&lt;/p&gt;

&lt;p&gt;启动activemq方式根据不同的操作系统平台是不一样的，在Mac下启动需要切换到activemq安装目录的bin目录下，然后再切换到macosx目录下，使用./activemq start启动，如果需要停止activemq就使用./activemq stop停止。&lt;/p&gt;

&lt;p&gt;然后可以启动一个程序来发送消息，这里使用Spring已经封装好的JmsTemplate来进行消息的发送。以下是一个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class JmsSendMessage {
	private JmsTemplate jmsTemplate;
	public void setJmsTemplate(JmsTemplate jmsTemplate) {
		this.jmsTemplate = jmsTemplate;
	}
	public void sendStudent(final Student student) {
		jmsTemplate.send(&quot;student&quot;, new MessageCreator(){
			public Message createMessage(Session session) throws JMSException {
				return session.createObjectMessage(student);
			}
		});
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个程序里面Student是自定义的一个对象，在发送信息的时候就是通过sendStudent(final Student student)将一个student对象作为消息发送。同时在调用jmsTemplate 的时候使用student 作为目的地，这种方式是直接在程序里面指定，不建议这么做。所以在接受消息的时候也需要从student 这个目的地接受。&lt;/p&gt;

&lt;p&gt;程序中使用到了jmsTemplate，所以需要对jmsTemplate进行配置，由于jmsTemplate需要连接jms服务器，所以需要把connectionFactory注入到jmsTemplate中，配置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;bean id=&quot;jmsTemplate&quot; class=&quot;org.springframework.jms.core.JmsTemplate&quot;&amp;gt;
	&amp;lt;property name=&quot;connectionFactory&quot; ref=&quot;connectionFactory&quot; /&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是接受消息的简单例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class JmsReceiveMessage {
	private JmsTemplate jmsTemplate;
	public void setJmsTemplate(JmsTemplate jmsTemplate) {
		this.jmsTemplate = jmsTemplate;
	}
	public Student getStudent() {
		ObjectMessage receivedMessage = (ObjectMessage) jmsTemplate.receive(&quot;student&quot;);
		try {
			Student student = (Student)receivedMessage.getObject();
			return student;
		} catch (JMSException e) {
			throw JmsUtils.convertJmsAccessException(e);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接收消息和发送消息都需要到spring的配置文件中进行配置，这里省略。&lt;/p&gt;

&lt;p&gt;启动activemq消息服务器后就可以调用JmsSendMessage 的sendStudent来发送消息，使用JmsReceiveMessage来接受消息，但是这里有一个问题需要注意，使用JmsReceiveMessage接收消息时，只要当有消息发送到student这个目的后才能接收到，如果没有消息会一直等待。这种方式对异步通信来说没有什么作用，所以下面是一个简单地消息监听器配置，通过消息监听器就可以让消息到来后系统自动帮你执行你指定的程序获取数据。&lt;/p&gt;

&lt;p&gt;spring提倡基于POJO的低侵入编程，所以这里在实现监听器的时候没有在程序中实现MessageListener这个监听器接口，而是在spring配置文件中通过配置的方式完成消息的监听。&lt;/p&gt;

&lt;p&gt;这个时候消息接受类就变成这样了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class JmsReceiveMessage {
	// 当消息到达后自动将消息放入student参数中（因为我们知道发送方就是发送的一个student，所以接受时消息能转成Student对象传入）
	public void getStudent(Student student) {
		...
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在spring的配置文件中的配置需要增加以下几行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;jms:listener-container connection-factory=&quot;connectionFactory&quot;&amp;gt;
	&amp;lt;jms:listener destination=&quot;student&quot; ref=&quot;jmsReceiveMessage&quot;
		method=&quot;getStudent&quot; /&amp;gt;
&amp;lt;/jms:listener-container&amp;gt;	
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样在消息达到后系统就会自动帮你执行jmsReceiveMessage 的getStudent方法。&lt;/p&gt;
</description>
				<pubDate>Sun, 25 Jan 2015 00:00:00 +0800</pubDate>
				<link>/2015/01/25/Spring%E5%AF%B9JMS%E6%95%B4%E5%90%88%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D.html</link>
				<guid isPermaLink="true">/2015/01/25/Spring%E5%AF%B9JMS%E6%95%B4%E5%90%88%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D.html</guid>
			</item>
		
			<item>
				<title>spring io 平台介绍</title>
				<description>&lt;p&gt;Spring IO Platform reference对Spring IO的介绍如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Spring IO Platform is primarily intended to be used with a dependency management system. It works well with both Maven and Gradle.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;具体如何理解Spring IO Platform 的作用了？&lt;/p&gt;

&lt;p&gt;以前在升级Spring项目的时候是手动的一个一个升级Spring模块的版本，并且一个模块与另一个模块之间的依赖适不适合你并不知道，你还需要测试或者找资料，所以比较麻烦。Spring IO Platform它能够结合Maven (或Gradle)管理每个模块的依赖，使得开发者不再花心思研究各个Java库相互依赖的版本，只需要引入Spring IO Platform即可，因为这些库的依赖关系Spring IO Platform已经帮你验证过了。&lt;/p&gt;

&lt;p&gt;在Maven中的使用也比较简单，只需要在pom.xml文件中加入依赖管理就可：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;dependencyManagement&amp;gt;
	&amp;lt;dependencies&amp;gt;
		&amp;lt;dependency&amp;gt; 
			&amp;lt;groupId&amp;gt;io.spring.platform&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;platform-bom&amp;lt;/artifactId&amp;gt;
			&amp;lt;version&amp;gt;1.1.2.BUILD-SNAPSHOT&amp;lt;/version&amp;gt; 
			&amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
			&amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;
		&amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&amp;lt;/dependencyManagement&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然也可以使用继承的方式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;parent&amp;gt; 
	&amp;lt;groupId&amp;gt;io.spring.platform&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;platform-bom&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;1.1.2.BUILD-SNAPSHOT&amp;lt;/version&amp;gt; 
	&amp;lt;relativePath/&amp;gt;
&amp;lt;/parent&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;http://docs.spring.io/platform/docs/1.1.2.BUILD-SNAPSHOT/reference/htmlsingle/&lt;/p&gt;

</description>
				<pubDate>Fri, 16 Jan 2015 00:00:00 +0800</pubDate>
				<link>/2015/01/16/spring_io_platform.html</link>
				<guid isPermaLink="true">/2015/01/16/spring_io_platform.html</guid>
			</item>
		
			<item>
				<title>feedback_me 插件的使用</title>
				<description>&lt;p&gt;This jQuery plug-in allows user to easily add an animatable UI widget with a feedback form which slides from the side of the screen.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;feedback_me 在使用后的效果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/5568742/5056362/a681f7e6-6cba-11e4-9eb2-bdcb2bf2d18d.png&quot; alt=&quot;1&quot; /&gt;
&lt;img src=&quot;https://cloud.githubusercontent.com/assets/5568742/5056363/c164806a-6cba-11e4-9f83-f38c9e18653a.png&quot; alt=&quot;2&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;它会附着在窗口的一边，点击后会出现信息表，填写完成后点击提交即可，提交完成后feedbach_me 会将填写的信息通过post请求发送到你指定的url地址，你可以在后台写一个controller专门负责接收这个请求。这个插件的好处在于整个过程使用简单、有效，只需要通过简单的配置就能完成。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;官方的文档的地址： http://plugins.jquery.com/feedback_me 
github的地址： https://github.com/vedmack/feedback_me&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;section&quot;&gt;看一下如何使用它：&lt;/h5&gt;

&lt;p&gt;首先他是一个jQuery 插件，需要在一开始引入jQuery，然后引入它指定的js和css文件即可。&lt;/p&gt;

&lt;p&gt;上图例子实现的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;link href=&quot;../../styles/jquery/jquery.feedback_me.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot; src=&quot;../../scripts/jquery/jquery.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot; src=&quot;../../scripts/jquery/plugin/jquery.feedback_me.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
	$(document).ready(function(){
		fm_options = {
			// 这个参数是设置这个反馈按钮在页面的哪个位置，left-bottom ...
    		position: &quot;right-top&quot;,
    		// 是否显示邮箱
    		show_email: true,
    		email_label: &quot;邮箱&quot;,
    		email_required: true,
    		// 单选框
   			show_radio_button_list: true,
   			radio_button_list_labels: [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;],
   			radio_button_list_title: &quot;给个好评哦...&quot;,
   			radio_button_list_required: false,
   			//
   			name_required: true,
    		name_label: &quot;名字&quot;,
			// 
			message_label: &quot;反馈信息&quot;,
			message_required: true,
    		show_asterisk_for_required: true,
    		// 这个很重要，这是提交后信息发送到哪里
    		feedback_url: &quot;http://.../feedback/message&quot;,
    		// 提交信息后提示
    		delayed_options: {
        		send_fail : &quot;提交失败 :(. &quot;,
       			 send_success : &quot;提交成功，谢谢参与反馈，^_^ !&quot;
    		},
    		submit_label: &quot;提交&quot;,
			// 页面按钮提示信息
			trigger_label: &quot;意见反馈&quot;
		};
		//init feedback_me plugin
		fm.init(fm_options);
	});
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
				<pubDate>Mon, 05 Jan 2015 00:00:00 +0800</pubDate>
				<link>/2015/01/05/feedback_me_%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8.html</link>
				<guid isPermaLink="true">/2015/01/05/feedback_me_%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8.html</guid>
			</item>
		
			<item>
				<title>Git提交错误后如何回退</title>
				<description>&lt;blockquote&gt;
  &lt;p&gt;在使用Git的时候需要维护一个自己的分支模型，推荐使用: 
http://nvie.com/posts/a-successful-git-branching-model/  &lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section&quot;&gt;总体说来有一下两点：&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;在中央仓库保存两个永久分支，master &amp;amp;&amp;amp; develop，master分支是发布分支，每次发布就是从master上打包发布，程序是不允许直接在master提交代码，只能通过其他分支合并到master分支。develop分支是开发分支，当develop上得源代码达到一个稳定状态的时候就可以把develop的代码合并到master上。&lt;/li&gt;
  &lt;li&gt;除去master和develop这两个永久分支，还存在一些暂时的分支。
    &lt;ul&gt;
      &lt;li&gt;线上的紧急Bug需要修复，这个时候就需要创建一个hotfix分支，这个分支是从master上检出，完成修复后双向合并到master和develop上，保证develop与master代码的同步，合并完后删除hotfix 分支。&lt;/li&gt;
      &lt;li&gt;还比如，要开发一个新功能，这个时候需要创建一个feature分支，这个分支就从develop上检出，可以把这个分支推到服务器上让更多地人参与开发，当然也可以不推倒服务器上，只在本地开发，开发完成后合并到develop上。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面这个是我们项目中的网络提交图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/5568742/5021605/91bdfa3e-6b12-11e4-8b66-3926fb2c0a29.png&quot; alt=&quot;test2&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这只是简单介说了一下分支模型，具体的介绍可以参考上面给出的链接。如果在提交的过程中直接在master上做了修改，或者不小心把master合并到了develop分支上，如何回退？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;master&quot;&gt;直接在master分支上修改代码并提交如何回退&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果直接在master分支上做了修改并提交到了服务器，这种操作在上面所描述的分支模型中是严格禁止的，如果出现这种情况如何回退：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;在本地切到master分支下，使用 git chenkout -b  temp-branch，这样就从master分支上创建了一个新的临时分支，并且切到这个分支下。&lt;/li&gt;
    &lt;li&gt;git reset –hard commitpoint, 这个commitpoint代表你要回滚的提交点&lt;/li&gt;
    &lt;li&gt;git branch -D master , 这个操作是删除本地master分支&lt;/li&gt;
    &lt;li&gt;git push origin :master, 删除远程服务器上得master分支，这里的删除就是推送一个空分支到远程master上。&lt;b&gt;但是注意的是远程master可能是一个default设置，这样服务器是不允许删除master分支，这个时候就需要在项目设置上将default标签切换到另一个分支上，上面的删除操作才能成功&lt;/b&gt;&lt;/li&gt;
    &lt;li&gt;将远程分支删掉后需要把回滚后的分支推到远程服务器上，git push origin temp-branch:master，这样就能完成回退操作&lt;/li&gt;
    &lt;li&gt;最后是删除temp-branch 分支，git checkout master, git branch -D temp-branch.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;
</description>
				<pubDate>Mon, 05 Jan 2015 00:00:00 +0800</pubDate>
				<link>/2015/01/05/Git%E6%8F%90%E4%BA%A4%E9%94%99%E8%AF%AF%E5%90%8E%E5%A6%82%E4%BD%95%E5%9B%9E%E9%80%80.html</link>
				<guid isPermaLink="true">/2015/01/05/Git%E6%8F%90%E4%BA%A4%E9%94%99%E8%AF%AF%E5%90%8E%E5%A6%82%E4%BD%95%E5%9B%9E%E9%80%80.html</guid>
			</item>
		
	</channel>
</rss>
